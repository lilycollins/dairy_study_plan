# 前言

大前端：1.服务端的一部分放在了前端的工作当中。BFF(中间层)层

​			   2.泛客户端开发，应用的形式越来越多了，web，桌面应用，app，H5，小程序等

​				3.传统Web技术的深入，各种框架

端开发（前端各种各样的客户端）+云开发（脱离后台，使用云函数开发）

##### 学习记录：

1.按照学习计划，夯实每一个细节

2.整理自己的笔记，夯实每一个细节

3.将笔记内容细化、总结和消化

4.按照要求完成对应的实践和练习

5.坚持写博客，与人分享，加深理解，自我沉淀



# part 1：Javascript深度剖析

## 一、函数式编程（Functional Programming，FP）编程范式

**本节回顾**

1.函数式编程（核心思想：把运算过程抽象成函数）

2.函数相关复习（函数是一等公民，高级函数，闭包）

3.函数式编程基础（lodash，纯函数，柯里化，管道，函数组合）

4.函子（Functor，MayBe，Either，IO， Task（folktale），Monad）帮助我们控制副作用，进行异常操作，异步处理等等

- 随着React的流行受到关注，Vue3也开始使用
- 函数式编程可以抛弃this
-    打包的时候可以更好利用tree shaking过滤无用代码
-    方便测试和并行处理
-   很多库可以帮助我们进行函数式开发：lodash、underscore、ramda

思维方式：把现实世界中的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象）

描述数据（函数）之间的映射

### 前置知识

#### 1.函数是一等公民

函数可以存储在变量中

函数可以作为参数

函数可以作为返回值

#### 2.高阶函数

可以帮我们屏蔽细节，只需要关注我们的目标，高阶函数式用来抽象通用的问题，代码更简洁

- 可以把函数作为一个参数传给另一个函数

eg：实现一个filter函数

- 函数作为返回值

eg：实现一个once函数

常用高阶函数： foreach，map，filter，every，some，filter，find/findIndex，reduce，sort......

#### 3.闭包

- 函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包

- 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员

闭包的本质：函数在执行的时候会被放到执行栈上，执行完毕会被移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员

好处：延长了外部函数内部变量的作用范围

案例：1.n的n次方；2.工资的等级

### 1.纯函数

概念：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

- lodash是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等一些方法，函数柯里化方法等

纯函数（eg:slice e 不会改变原数组）和不纯函数(eg:splice会改变原数组)

- 不会保留计算中间的结果，所以变量是不可变的（无状态的）


- 我们可以把一个函数的执行结果交给另一个函数去处理不会改变原数组

- 不会保留计算中间的结果，所以变量是不可变的（无状态的）

- 我们可以把一个函数的执行结果交给另一个函数去处理

###### 好处

​			1.可缓存（eg：带记忆的函数  模拟lodash中的memoize方法的实现）

​			2.可测试（始终有输入输出，在断言结果）

​            3.并行处理

​				在多线程情况下并行操作共享的数据（eg：全局变量）的时候可能会发生意外情况

​				纯函数不需要访问共享的内存数据，所以并行环境下可以任意运行纯函数（web worker）

###### 副作用

​	没有任何可观察的副作用。如果函数依赖于外部的状态就无法保证输出相同

​	来源：1.配置文件；2.数据库；3.获取用户的输入等外部交互......

​	副作用会使得方法通用性下降不适合扩展和可重用性，同时会给程序带来安全隐患和不确定性，但副作用不可能完全禁止，只能把他们置于可控范围内

### 柯里化

eg：使用柯里化来解决硬编码的问题。checkAge

- 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）

- 然后返回一个新的函数接受剩余的函数，返回结果

eg：模拟lodash中的柯里化

#### 总结

- 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新的函数

- 这是一种对函数参数的‘缓存’

- 让函数变得更加灵活，函数粒度更小

- 可以把多元函数转换成一元函数，可以组合成功能更强大的函数

### 函数组合

纯函数和柯里化很容易写出洋葱代码，一层包一层。类似于h(g(f(x)))

管道：大函数拆分成小函数

fn = compose(f1, f2, f3)

b=fn(a)

#### 概念

如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数

​	**默认从右到左执行**

#### 组合函数的实现原理

eg: 模拟lodash中的组合函数

#### 结合律

我们既可以把f1,f2函数组合，还可以把f2和f3组合，结果都是一样的

#### 调试

### fp模块（function programmer）

提供了实用的对**函数式编程**友好的方法

提供了不可变 **auto-curried  literatee-first data-last** 的方法

自动柯里化，函数优先 数据滞后

 lodash和lodash/fp 模块中map方法的区别 （eg：用map把数组的中的项转为数字）



### Point Free

#### 概念

我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数

只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数

- 不需要指明处理的数据

- **只需要合成运算过程**

- 需要定义一些辅助的基本运算函数

函数组合也是Point Free的思想

#### 案例

eg：把一个字符串中的首字母提取并转换成大写，使用.作为分隔符。world wild web ===> W.W.W



### Functor 函子

#### class和function

es6中的class是js原型继承的一种语法糖。js中的class就是一种特殊的function

##### class与function的相同和异同点

1.先声明后使用，不能重复定义，存在变量提升，但是无法初始化，class调用必须通过new关键字

ES6引入了Class（类）这个概念，通过class关键字可以定义类。constructor是一个构造方法，用来接收参数，constructor方法默认返回实例对象this，但是也可以指定constructor方法返回一个全新的对象，让返回的实例对象不是该类的实例

constructor外声明的属性都是定义在原型上的，可以称为原型属性

#### 概念

建立在数学的范畴论的基础上

把函数式编程中的副作用控制在可控范围之后，还可以处理一些异常和异步操作

容器：包含值和值的变形关系（这个变形关系就是函数）

函子：是一个特殊的容器，通过一个普通的对象来实现。该对象具有map方法，map方法可以运行一个函数对值进行处理（变形关系）

#### 实际函子

##### maybe函子

对外部空值的情况做处理，控制副作用在合理范围内

##### Either函子

类似if...else，可以做异常处理

##### IO函子

- 内部的_value始终是一个函数，把函数作为值来处理

- 可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行）

- 把不纯的操作交给调用者来处理

##### folktale

一个函数式编程库

folktale与lodash、ramda不同的是，他没有提供很多功能函数，只是一些函数式处理的操作，例如compose、curry，一些函子Task、Either、Maybe等

##### Task函子

处理异步任务

使用 Folktale函数（2.3.2版本）式编程库 中的Task来演示

##### Pointed函子

实现了of静态方法的函子

of方法是为了避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文Context（把值放到容器中，使用map来处理值）

##### Monad函子

可以变扁的Pointed函子

一个函子如果具有join和of两个方法并遵守一些定律就是一个Monad

#### 总结

函数式编程的运算不直接操作值，而是由函子完成

函子就是一个实现了map契约的对象

我们可以把函子想象成一个盒子，这个盒子里封装了一个值

想要处理盒子里的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理

最后map方法返回一个包含新值的函子



## 二、JavaScript异步编程

### 概述

**本节概要**

1.同步模式与异步模式

2.时间循环与消息队列

3.异步编程的几种方式

4.Promise异步方案、宏任务/微任务队列

5.Generator异步方案、Async/Await语法糖



单线程JavaScript单线程工作的原因：JS执行环境中负责执行代码的线程只有一个，js代码是运行在浏览器上，主要负责页面动态交互， DOM操作，为避免出现线程同步问题，所以单线程操作。

任务执行模式：同步模式、异步模式

#### 回调函数

**回调函数是所有异步编程的方案的根基**

回调函数是由调用者定义，交给执行者执行的函数

#### Promise

解决回调地狱问题

unhandledRejection 捕获未手动捕获的异常



## 三、手写Promise源码

见代码文件


