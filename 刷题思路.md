之前陆陆续续有刷过一段时间的leetcode，数组，动态规划之类的，发现一个问题，记忆不是很好，刷完就容易忘，下次遇到一类的题型，思路还是卡壳，也许是菜，也许也是智商不够用或者是记忆力差。为了弥补这一缺陷，每次刷题的时候记录下自己的脑回路以及做题历程，同时也为了之后的回顾。之前刷过的题目慢慢补齐把，从现在刷的题开始都记录下，工作经验一年一年累加，不能再菜的不行不行的了。lets start

## 题目类型：

### 一、排序

#### 1.重新排列字符串(leetcode/2020.12.17/1528)

```
题目描述： 给你一个字符串 s 和一个 长度相同 的整数数组 indices 。请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置。 返回重新排列后的字符串。
eg：输入：s = "codeleet", indices = [4,5,6,7,0,2,1,3]。输出："leetcode"
解释："codeleet" 重新排列后变为 "leetcode" 。 
```

原始思路：首先把字符串和序号数组建立联系，然后给序号排序，之后输出的字符串就是正确的顺序了。一开始是想把它拼成对象键值对的方式，一一对应然后排序，but可能是自己太菜，实际操作出了点错误，键名是字符串的话会有重复值被覆盖的情况，键名是索引的时候，赋值有些键名是undefined，就不死磕了。然后就换成对象数组的方式然后排序排序之后再循环拼接字符串。这里循环次数就有点多，渣渣代码。后面我看了下人家的思路，果然清晰好多，菜的安详。

纠正思路：创建一个与字符串长度相等的空数组，然后遍历这个数组，把这个数组与数组下标的索引对应arr[indices[i]] = s.charAt(i) ，arr这个数组就是排序好的数组了。

### 二、动态规划

#### 1.爬楼梯(leetcode/2020.12.21/70) 

```
题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```

初步思路：乍一看其实还是有点懵，毕竟组合类型概率我一直都没学好。然后往下翻看了下题目类型，动态规划类。好像有了些许的思路。‘do or notdo’的这个印象很深刻啊。可以数量从高到低依次排列啊。主要是状态转移方程规律。6级可以是posibility（5）+（x）中可能性。这个多一级多几种可能性的我好像没想明白。emm...重新读了一下题目，每次只能爬1 或 2 个台阶所以就意味着posibility(x) = posibility（x-1）+ posibility（x-2），是可能性的累加。思路正确，编码顺利

#### 2.使用最小花费爬楼梯(leetcode/2020.12.21/746) 

```
题目描述：数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```

初步思路：求最小值问题。一共有cost.length级阶梯，设为x。状态转移方程应该是F(x)=Math.Min(F(x-1)，F(x-2))

纠正思路：状态转移方程错误。应该把上一次的结果也加上，上面的方程变成单纯求最小值了，想想当时怎么写出来这样的转移方程。而且还有一个注意点，如果数组长度<=2的时候应该都是0。正确的方程应该是

dp[i]=Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])

#### 3.零钱兑换(leetcode/2020.03.01/322) 

```
题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
你可以认为每种硬币的数量是无限的。
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
输入：coins = [2], amount = 3
输出：-1
```

初步思路：（undone）
纠正思路：可以设置总金额amount作为最少硬币个数初始值initial。然后去递归循环，找到最优子结构（选哪枚硬币），最优子结构+1就是最优解optimize（Math.min(subOpt + 1， initial)）。如果最优子结构金额小于零则跳过选硬币循环。金额小于0，return -1（无法匹配），金额=0，return 0。最终返回最优解optimize

#### 4.连续数列(leetcode/2020.03.03/16.17) 

```
题目描述：给定一个整数数组，找出总和最大的连续数列，并返回总和。
输入： [-2,1,-3,4,-1,2,1,-5,4]
输出： 6
解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

思路：需要考虑一点就是，如果连续的相加值为复数的情况下，就可以认为前面的数组无意义，连续数列第一项可以从当前循环到的值去取。然后记录下每轮循环的最大值。返回就是总和最大的连续数列

动态规划：状态转移方程：dp(i)=Math.max(dp[i-1]+nums[i], nums[i])。最后取dp数组的最大值

### 三、数组

#### 1.最小绝对差(leetcode/2020.12.21/1200) 

```
给你个整数数组 arr，其中每个元素都不相同。
请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。
输入：arr = [4,2,1,3]
输出：[[1,2],[2,3],[3,4]]
输入：arr = [1,3,6,10,15]
输出：[[1,3]]
输入：arr = [3,8,-10,23,19,-4,-14,27]
输出：[[-14,-10],[19,23],[23,27]]
```

初步思路：1.首先设置数组索引1-索引2为最小值，数组循环遍历相减，双指针法，如果有更小的则输出。2.先给数组排序，然后判断相邻项之间的绝对差，返回最小。再遍历一遍把最小值的可能组合输出。做是做出来了，感觉有点绕，循环次数有点多。看看其他的思路把。

其他思路：emm,差不太多，基本都是先排序再比较相邻两项取出。可以少循环一次，最后一次遍历与第二次放在一起

#### 2.最富有客户的资产总量(leetcode/2020.12.24/1672) 

```
给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第i位客户在第j家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。
客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。
输入：accounts = [[1,5],[7,3],[3,5]]
输出：10
解释：
第 1 位客户的资产总量 = 6
第 2 位客户的资产总量 = 10 
第 3 位客户的资产总量 = 8
第 2 位客户是最富有的，资产总量是 10
```

思路：先设定第1位客户是最富有的，存储第一位客户的资产总量为max。循环accounts数组。获取二维数组里一维数组的和sum，每一轮与max对比取最大值赋为max。循环结束则返回max。

#### 3.无法吃午餐的学生数量（leetcode/2020.12.29/1700）

```
学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：
如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。
否则，这名学生会 放弃这个三明治 并回到队列的尾部。
这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。
输入：students = [1,1,0,0], sandwiches = [0,1,0,1]
输出：0 
输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
输出：3
```

思路：原来是打算使用计数法，直接算出student和sandwishes中0和1的数量，相减。这样忽略了一个题目规定，只要顶层的三明治没人喜欢就结束，所以单纯的统计想减无法满足需求。只要顶层的三明治为0（or 1），学生数组为1（or 0）的情况就可以返回学生数组长度了。设置一个循环，循环终止条件为students数组不包含sandwishes的栈顶元素就跳出循环。比较两个元素的栈顶元素，相同则splice，不同则把students数组元素往后推。循环之后返回的students数组的长度就是无法吃午餐的学生数量。

#### 4.好数对的数目（leetcode/2021.1.4/1512）

```
给你一个整数数组 nums 。
如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 。
返回好数对的数目。
输入：nums = [1,2,3,1,1,3]
输出：4
解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始
输入：nums = [1,1,1,1]
输出：6
解释：数组中的每组数字都是好数对
```

思路：双重循环，初始count设为0，满足nums[i]==nums[j]且i<j则count++，返回count。

新名词：双游标。如下所示

​			for (let i = 0; i < nums.length; j++) {
​    			 if (j === nums.length) i++, j = 0
​    			 i < j && nums[j] === nums[i] && count++
​			}

#### 5.数组中数字出现的次数（leetcode/2021.2.3/[剑指 Offer 56 - I）

```
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

思路：没啥思路，看了下题解很多都是异或、位运算之类的不太会，下次再看把

#### 6.爱生气的书店老板（leetcode/2021.2.23/[1052）- sliding window 滑动窗口算法

```
今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。
在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。
书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。
请你返回这一天营业下来，最多有多少客户能够感到满意的数量。
输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
输出：16
解释：
书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
```

思路：比较状态为1的值最大值，然后发散出与该值连续的X个值得最大值。把这个范围内grumpy置为1，然后累加为1得customers, 绕来绕去的，实际编码的时候也遇到不知如何下手的情况，中止编码

纠正思路：可动过滑动窗口算法来算，时间和空间复杂度也比较优秀。首先循环将初始满意客户数量累加。将第一轮<x并且不高兴的相加设置为初始值，然后往右移动，移走的就减去当前客户数，添加的加上当前客户数，每轮循环记录下最大值。结果就是初始满意客户数+每轮循环记录下的最大值。

if(i<X && grumpy[i]) {  total += customers[i]  } 

else {

​    if(grumpy[i-X]) { total -= customers[i-X]}

​    if(grumpy[i]) { total += customers[i] }

} 


### 四、字符串

#### 1.字符串中的第一个唯一字符(leetcode/2020.12.23/387) 

```
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
s = "leetcode"
返回 0
s = "loveleetcode"
返回 2
```

初步思路：可以设置一个栈，存储索引和值，如果有相同的索引则出栈，返回栈顶索引。做的时候发现个问题，如果出现了奇数次，比如三次，两次出栈，第三次又会被进栈。这是个值得考虑的点。

纠正思路：看了一个官方思路，就是先循环一遍把值和出现次数存起来，然后再遍历，返回第一个次数为1的字符。或者直接遍历，返回第一个indexOf和lastIndexOf值一致的字符。

### 五、栈

#### 1.移除无效的括号(leetcode/2020.12.28/1249) 

```
给你一个由 '('、')' 和小写字母组成的字符串 s。
你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。
请返回任意一个合法字符串。
有效「括号字符串」应当符合以下 任意一条 要求：
    空字符串或只包含小写字母的字符串
    可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
    可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」
输入：s = "a)b(c)d"
输出："ab(c)d"
```

初步思路：设置一个栈，只维护一个栈元素。 可以存储（） 遍历字符串，遇到charAt('(')进栈，需要存储索引，未出栈时需要移除一个"("，好像移除的顺序不限制，所以也可不存储索引(顺序很重要，用栈元素存储索引，循环结束栈还有值的话需要删除对应的索引，同时尽量避免使用splice，会改变原数组，下标不准，使用delete)，遇到charAt(')')的出栈

### 六、递归

#### 1.递归乘法(leetcode/2020.12.29/面试题08.05) 

```
递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
提示：保证乘法范围不会溢出
输入：A = 1, B = 10
输出：10
输入：A = 3, B = 4
输出：12
```

初步思路：不过不能用相乘的话，就是循环A次将B相加。然后有个注意点，尽量比较A和B的值并且循环值比较小的那个。或者使用递归，本质上也就是 A+multiply（A，B-1）