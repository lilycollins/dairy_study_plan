之前陆陆续续有刷过一段时间的leetcode，数组，动态规划之类的，发现一个问题，记忆不是很好，刷完就容易忘，下次遇到一类的题型，思路还是卡壳，也许是菜，也许也是智商不够用或者是记忆力差。为了弥补这一缺陷，每次刷题的时候记录下自己的脑回路以及做题历程，同时也为了之后的回顾。之前刷过的题目慢慢补齐把，从现在刷的题开始都记录下，工作经验一年一年累加，不能再菜的不行不行的了。lets start

## 题目类型：

### 一、排序

#### 1.重新排列字符串(leetcode/12.17/1528)

```
题目描述： 给你一个字符串 s 和一个 长度相同 的整数数组 indices 。请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置。 返回重新排列后的字符串。
eg：输入：s = "codeleet", indices = [4,5,6,7,0,2,1,3]。输出："leetcode"
解释："codeleet" 重新排列后变为 "leetcode" 。 
```

原始思路：首先把字符串和序号数组建立联系，然后给序号排序，之后输出的字符串就是正确的顺序了。一开始是想把它拼成对象键值对的方式，一一对应然后排序，but可能是自己太菜，实际操作出了点错误，键名是字符串的话会有重复值被覆盖的情况，键名是索引的时候，赋值有些键名是undefined，就不死磕了。然后就换成对象数组的方式然后排序排序之后再循环拼接字符串。这里循环次数就有点多，渣渣代码。后面我看了下人家的思路，果然清晰好多，菜的安详。

纠正思路：创建一个与字符串长度相等的空数组，然后便利这个数组，把这个数组与数组下标的索引对应arr[indices[i]] = s.charAt(i) ，arr这个数组就是排序好的数组了。

### 二、动态规划

#### 1.爬楼梯(leetcode/12.21/70) 

```
题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```

初步思路：乍一看其实还是有点懵，毕竟组合类型概率我一直都没学好。然后往下翻看了下题目类型，动态规划类。好像有了些许的思路。‘do or notdo’的这个印象很深刻啊。可以数量从高到低依次排列啊。主要是状态转移方程规律。6级可以是posibility（5）+（x）中可能性。这个多一级多几种可能性的我好像没想明白。emm...重新读了一下题目，每次只能爬1 或 2 个台阶所以就意味着posibility(x) = posibility（x-1）+ posibility（x-2），是可能性的累加。思路正确，编码顺利

#### 2.使用最小花费爬楼梯(leetcode/12.21/746) 

```
题目描述：数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```

初步思路：求最小值问题。一共有cost.length级阶梯，设为x。状态转移方程应该是F(x)=Math.Min(F(x-1)，F(x-2))

纠正思路：状态转移方程错误。应该把上一次的结果也加上，上面的方程变成单纯求最小值了，想想当时怎么写出来这样的转移方程。而且还有一个注意点，如果数组长度<=2的时候应该都是0。正确的方程应该是

dp[i]=Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])

#### 2.最小绝对差(leetcode/12.21/1200) 

```
给你个整数数组 arr，其中每个元素都 不相同。
请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。
输入：arr = [4,2,1,3]
输出：[[1,2],[2,3],[3,4]]
输入：arr = [1,3,6,10,15]
输出：[[1,3]]
输入：arr = [3,8,-10,23,19,-4,-14,27]
输出：[[-14,-10],[19,23],[23,27]]
```

初步思路：1.首先设置数组索引1-索引2为最小值，数组循环遍历相减，双指针法，如果有更小的则输出。2.先给数组排序，然后判断相邻项之间的绝对差，返回最小。

