之前陆陆续续有刷过一段时间的leetcode，数组，动态规划之类的，发现一个问题，记忆不是很好，刷完就容易忘，下次遇到一类的题型，思路还是卡壳，也许是菜，也许也是智商不够用或者是记忆力差。为了弥补这一缺陷，每次刷题的时候记录下自己的脑回路以及做题历程，同时也为了之后的回顾。之前刷过的题目慢慢补齐把，从现在刷的题开始都记录下，工作经验一年一年累加，不能再菜的不行不行的了。lets start

## 题目类型：

### 一、排序

#### 1.重新排列字符串(leetcode/12.17/1528)

```
题目描述： 给你一个字符串 s 和一个 长度相同 的整数数组 indices 。请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置。 返回重新排列后的字符串。
eg：输入：s = "codeleet", indices = [4,5,6,7,0,2,1,3]。输出："leetcode"
解释："codeleet" 重新排列后变为 "leetcode" 。 
```

原始思路：首先把字符串和序号数组建立联系，然后给序号排序，之后输出的字符串就是正确的顺序了。一开始是想把它拼成对象键值对的方式，一一对应然后排序，but可能是自己太菜，实际操作出了点错误，键名是字符串的话会有重复值被覆盖的情况，键名是索引的时候，赋值有些键名是undefined，就不死磕了。然后就换成对象数组的方式然后排序排序之后再循环拼接字符串。这里循环次数就有点多，渣渣代码。后面我看了下人家的思路，果然清晰好多，菜的安详。

纠正思路：创建一个与字符串长度相等的空数组，然后遍历这个数组，把这个数组与数组下标的索引对应arr[indices[i]] = s.charAt(i) ，arr这个数组就是排序好的数组了。

### 二、动态规划

#### 1.爬楼梯(leetcode/12.21/70) 

```
题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```

初步思路：乍一看其实还是有点懵，毕竟组合类型概率我一直都没学好。然后往下翻看了下题目类型，动态规划类。好像有了些许的思路。‘do or notdo’的这个印象很深刻啊。可以数量从高到低依次排列啊。主要是状态转移方程规律。6级可以是posibility（5）+（x）中可能性。这个多一级多几种可能性的我好像没想明白。emm...重新读了一下题目，每次只能爬1 或 2 个台阶所以就意味着posibility(x) = posibility（x-1）+ posibility（x-2），是可能性的累加。思路正确，编码顺利

#### 2.使用最小花费爬楼梯(leetcode/12.21/746) 

```
题目描述：数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```

初步思路：求最小值问题。一共有cost.length级阶梯，设为x。状态转移方程应该是F(x)=Math.Min(F(x-1)，F(x-2))

纠正思路：状态转移方程错误。应该把上一次的结果也加上，上面的方程变成单纯求最小值了，想想当时怎么写出来这样的转移方程。而且还有一个注意点，如果数组长度<=2的时候应该都是0。正确的方程应该是

dp[i]=Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])

### 三、数组

#### 1.最小绝对差(leetcode/12.21/1200) 

```
给你个整数数组 arr，其中每个元素都不相同。
请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。
输入：arr = [4,2,1,3]
输出：[[1,2],[2,3],[3,4]]
输入：arr = [1,3,6,10,15]
输出：[[1,3]]
输入：arr = [3,8,-10,23,19,-4,-14,27]
输出：[[-14,-10],[19,23],[23,27]]
```

初步思路：1.首先设置数组索引1-索引2为最小值，数组循环遍历相减，双指针法，如果有更小的则输出。2.先给数组排序，然后判断相邻项之间的绝对差，返回最小。再遍历一遍把最小值的可能组合输出。做是做出来了，感觉有点绕，循环次数有点多。看看其他的思路把。

其他思路：emm,差不太多，基本都是先排序再比较相邻两项取出。可以少循环一次，最后一次遍历与第二次放在一起

#### 2.最富有客户的资产总量(leetcode/12.24/1672) 

```
给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第i位客户在第j家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。
客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。
输入：accounts = [[1,5],[7,3],[3,5]]
输出：10
解释：
第 1 位客户的资产总量 = 6
第 2 位客户的资产总量 = 10 
第 3 位客户的资产总量 = 8
第 2 位客户是最富有的，资产总量是 10
```

思路：先设定第1位客户是最富有的，存储第一位客户的资产总量为max。循环accounts数组。获取二维数组里一维数组的和sum，每一轮与max对比取最大值赋为max。循环结束则返回max

### 四、字符串

#### 1.字符串中的第一个唯一字符(leetcode/12.23/387) 

```
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
s = "leetcode"
返回 0
s = "loveleetcode"
返回 2
```

初步思路：可以设置一个栈，存储索引和值，如果有相同的索引则出栈，返回栈顶索引。做的时候发现个问题，如果出现了奇数次，比如三次，两次出栈，第三次又会被进栈。这是个值得考虑的点。

纠正思路：看了一个官方思路，就是先循环一遍把值和出现次数存起来，然后再遍历，返回第一个次数为1的字符。或者直接遍历，返回第一个indexOf和lastIndexOf值一致的字符。

### 五、栈

#### 1.移除无效的括号(leetcode/12.28/1249) 

```
给你一个由 '('、')' 和小写字母组成的字符串 s。
你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。
请返回任意一个合法字符串。
有效「括号字符串」应当符合以下 任意一条 要求：
    空字符串或只包含小写字母的字符串
    可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
    可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」
输入：s = "a)b(c)d"
输出："ab(c)d"
```

初步思路：设置一个栈，只维护一个栈元素。 可以存储（） 遍历字符串，遇到charAt('(')进栈，需要存储索引，未出栈时需要移除一个"("，好像移除的顺序不限制，所以也可不存储索引(顺序很重要，用栈元素存储索引，循环结束栈还有值的话需要删除对应的索引，同时尽量避免使用splice，会改变原数组，下标不准，使用delete)，遇到charAt(')')的出栈