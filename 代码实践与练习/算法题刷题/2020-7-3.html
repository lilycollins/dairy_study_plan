<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #box{
            width: 80px;
            margin: 20px;
            cursor: pointer;
            border:1px solid #333;
            padding: 10px;
        }
    </style>
</head>
<body>
    <p id='box'>疯狂点击把</p>
    <script>
        let box = document.getElementById('box')
        box.addEventListener('click',function(){
            debounce(logFn,1000)
            // throat(logFn,1000)
        })
        function logFn(){
            console.log('hahahahaha')
        }
        console.log('--------------fighting---------------')
        // 防抖函数 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。执行最后一次
        // 立即执行
        var timer;
        function debounce(fn,delay){
            if(timer){clearTimeout(timer)}
            let isActive = !timer
            timer = setTimeout(() => {
                timer = null
            }, delay);
            if(isActive){
                fn()
            }
        }
        
        // 延迟执行
        // var timer;
        // function debounce(fn,delay){
        //     clearTimeout(timer) 
        //     timer = setTimeout(()=>{
        //        fn()
        //     },delay)       
        // }
        
        // 节流函数 n秒内执行一次
        // var timer = null
        // function throat(fn,delay){
        //     if(!timer){
        //         timer = setTimeout(() => {
        //             fn()
        //             timer = null
        //         }, delay);
        //     }
        // }



        // 查找数组中两个不相邻的数字相加的最大值
        // 方法1 递归
        // function subset(arr,i){
        //     if(i == 0){
        //         return arr[0]
        //     }
        //     else if(i == 1){
        //         return Math.max(arr[0],arr[1])
        //     }
        //     else{
        //         return Math.max(arr[i]+subset(arr,i-2),subset(arr,i-1))
        //     }
        //     console.log(111,arr)
        // }
        // console.log(subset([1,2,35,6,8,6,4],6))
        // 方法2 动态规划
        // function subset(arr){
        //     console.log(arr)
        //     let opt = new Array(arr.length).fill(0)
        //     opt[0] = arr[0]
        //     opt[1] = Math.max(arr[0],arr[1])
        //     for(var i=2;i<arr.length;i++){
        //         opt[i] = Math.max(arr[i]+opt[i-2],opt[i-1])
        //     }
        //     return opt[arr.length-1]
        // }
        // console.log(subset([1,2,35,6,8,6,4]))



        // 查找数组中是否有数字相加为一个固定值，有返回true 无返回false
        // 递归
        // 实现对象的深度克隆,需要深度学习一下  RegExp function Date
        // 查找两个字符串中的最长的公共子串---好难
        // 留给明天


        // 给定两个数组，编写一个函数来计算它们的交集。
        var intersection = function(nums1, nums2) {
            // 方法1
            // let res=[]
            // for(var i=0;i<nums1.length;i++){
            //     for(var j=0;j<nums2.length;j++){
            //         console.log(nums1[i],nums2[j])
            //         if(nums1[i]==nums2[j]){
            //             res.push(nums1[i])
            //         }
            //     }
            // }
            // res = [...new Set(res)]
            // return res
            // 方法2
            // let res = []
            // for(var i=0;i<nums2.length;i++){
            //     if(nums1.includes(nums2[i]))
            //     res.push(nums2[i])
            // }
            // return [...new Set(res)]
            // 方法3
            let res = nums2.filter((ele,index)=>{
                return nums1.includes(ele)
            })
            return [...new Set(res)]
        };
        intersection([1,2,3,4,5],[4,4])

    </script>
</body>
</html>