<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>面试题code</title>
</head>
<body>
    <script>
        console.log("let's start")
        // 解析url字符串为Object
        // function parseUrl(str){
        //     let obj = {}
        //     console.log(str)
        //     obj.protocol = str.split(':')[0]
        //     obj.host = str.split('/')[2]
        //     obj.hash = str.split('#')[1]
        //     let inner
        //     if(str.indexOf('#')){
        //         inner = str.substring(str.indexOf('?')+1,str.indexOf('#'))
        //     }
        //     else{
        //         inner = str.substring(str.indexOf('?')+1)
        //     }
        //     var arr = inner.split('&')
        //     obj.param = {}
        //     for(var i=0;i<arr.length;i++){
        //         arr[i]=arr[i].split('=')
        //         obj.param[arr[i][0]] = arr[i][1]
        //     }
        //     obj.path = str.substring(str.indexOf(obj.host),str.indexOf('?')).slice(obj.host.length+1)
        //     console.log(obj)
        // }
        // parseUrl("http://www.xiyanghui.com/product/list?id=123456&sort=discount#title")



        // // 数组解析
        // let arr = [
        //     {id:1,name:'小明'},
        //     {id:1,name:'小红'},
        //     {id:1,name:'小兰'},
        //     {id:1,name:'小张'},
        //     {id:2,name:'小红'},
        //     {id:2,name:'小兰'},
        //     {id:2,name:'小张'},
        //     {id:3,name:'小红'},
        //     {id:3,name:'小兰'},
        //     {id:3,name:'小张'},
        // ]
        // 方法1
        // function formatArr(arr){
        //     let obj = {}
        //     arr.forEach((element,index) => {
        //         if(!obj[element.id]){
        //             obj[element.id] = [element.name]
        //         }
        //         else{
        //             obj[element.id].push(element.name)
        //         }
        //     });
        //     let result = []
        //     for(var i in obj){
        //         var item = {id:i,name:obj[i]}
        //         result.push(item)
        //     }
        //     return result;
        // } 
        // 方法2  
        // function formatArr(arr){
        //     let result = [];      
        //     for(var i=0; i<arr.length; i++){
        //         let index = result.findIndex((ele)=>{
        //             return ele.id == arr[i].id
        //         })
        //         if(index<0){
        //             result.push({id:arr[i].id,name:[arr[i].name]})
        //         }
        //         else{
        //             result[index].name.push(arr[i].name)
        //         }
        //     }
        // }     
        // formatArr(arr)
        


        //常见正则
        // /^[a-zA-Z][a-zA-Z0-9_]{4,15}$/ 5-16个字节，字母开头，允许字母数字和下划线
        // /^\d{15}|\d{18}$/ 身份证号，15或18位
        // /^[1-9]\d*$/  正整数正则   /^([1-9]\d+)|([2-9])$/ 大于1的正整数
        // /^[A-Za-z0-9]{3,20}$/ 3-20位大小写字母或数字组合



        // 超大字符串数字相加的实现
        //  小数相加减失精的方法
        // function getNum(a,b){           
        //     let arr = a.substr(a.indexOf('.')+1).length
        //     let arr2 = b.substr(b.indexOf('.')+1).length
        //     let j = Math.max(arr,arr2)
        //     let m = Number(a) * Math.pow(10,j)
        //     let n = Number(b) * Math.pow(10,j)         
        //     return (m+n)/Math.pow(10,j)
        // }
        // console.log(getNum('0.1','0.2'))



        /*
        给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
            对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
            你可以返回任何满足上述条件的数组作为答案。*/
        // var sortArrayByParityII = function(A) {
        //     let result = []
        //     let ji = [],ou = [],len = A.length;
        //     for(var i=0;i<A.length;i++){
        //         if(A[i]%2){
        //             ji.push(A[i])
        //         }else{
        //             ou.push(A[i])
        //         }
        //     }
        //     ou.forEach((ele,index)=>{
        //         ou[index] = ele + '+' + ji[index]
        //         ou[index] = ou[index].split('+')
        //     })
        //     return ou.flat()
        // }
        // sortArrayByParityII([4,2,5,7])



        // 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
        // var monotoneIncreasingDigits = function(N) {   
        //     if(N<10) {return N}    
        //     let arr = String(N).split('')
        //     let len = arr.length
        //     let isMatch = true
        //     for(var i=0;i<len;i++){
        //         if(arr[i+1]<arr[i]){
        //             isMatch = false
        //         }
        //     } 
        //     return isMatch?N:monotoneIncreasingDigits(N-1)
        // };
        // console.log(monotoneIncreasingDigits(32600))
        // 使用递归，性能可能会不好



        /*
        设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。（时间复杂度O(1)）
        push(x) —— 将元素 x 推入栈中。
        pop() —— 删除栈顶的元素。
        top() —— 获取栈顶元素。
        getMin() —— 检索栈中的最小元素。
        */
        // 方法1，设立一个数据栈，一个最小值栈       
        // var MinStack = function() {
        //     this.data = [],this.min = [] 
        // };
        // MinStack.prototype.push = function(x) {
        //     this.data.push(x)
        //     if(this.min.length === 0 || x <= this.min[this.min.length-1]){               
        //         this.min.push(x)
        //     }
        // }
        // MinStack.prototype.pop = function() {
        //     let a = this.data.pop()
        //     if(this.min[this.min.length-1] == a){
        //         this.min.pop()
        //     }
        // }
        // MinStack.prototype.top = function() {
        //     return this.data[this.data.length-1]
        // }
        // MinStack.prototype.getMin = function() {
        //     return this.min[this.min.length-1]
        // }
        // 方法2，设立一个栈，分别存储value和最小值
        // var MinStack = function() {
        //     this.data = []
        // };
        // MinStack.prototype.push = function(x) {
        //     if(this.data.length === 0 || x <= this.data[this.data.length-1].min){
        //         this.data.push({data:x,min:x})
        //         console.log(this.data)
        //     }
        //     else{
        //         this.data.push({data:x,min:this.data[this.data.length-1].min})
        //     }
        // }
        // MinStack.prototype.pop = function() {
        //     this.data.pop()
        // }
        // MinStack.prototype.top = function() {
        //     return this.data[this.data.length-1].data
        // }
        // MinStack.prototype.getMin = function() {
        //     return this.data[this.data.length-1].min
        // }
        // var minstack = new MinStack()
        // minstack.push(1)
        // minstack.push(2)


    </script>
</body>
</html>