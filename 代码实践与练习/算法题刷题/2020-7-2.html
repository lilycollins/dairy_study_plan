<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="box" style="width: 100px;height: 100px;background-color: blueviolet;">
    </div>
    <input type="text" id="input">
    <p id="text"></p>
    <script>
        // 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置。
        let box = document.getElementById('box')
        box.onclick = function cc(){
            console.log(111)
        }
        box.onclick = function bb(){
            console.log(222)
        }
        document.addEventListener('click',function(e){
            console.log('addeventlistener')
            if(e.target.id == 'box'){
                box.style.border = '1px solid red'
            }
            else{
                box.style.border = 'none'
            }
        })


        // 简单实现双向数据绑定mvvm
        // var obj = {}
        // var input = document.getElementById('input')
        // var text = document.getElementById('text')
        // Object.defineProperty(obj, 'text',{
        //     get: ()=> {
        //     return obj
        // },
        // set: (newValue)=> {
        //     document.getElementById('text').innerHTML = newValue
        // }
        // })
        // document.addEventListener('keyup',(e)=>{
        //     obj.text = e.target.value
        // })


    //    全排列组合 [1,2,3,4]复习 迭代法 n*2^n
        // function getChild(nums){
        //     let result = [[]]
        //     for(var i=0;i<nums.length;i++){
        //         let len = result.length
        //         for(let j=0;j<len;j++){
        //             result.push(result[j].concat(nums[i]))
        //         }
        //     }
        //     console.log(result)
        // }
        // getChild([1,2,3,4])

        // 函数A和函数B，请你实现B继承A
        // function A(){
        //     this.aaa='res'
        // }
        // function B(){     
        //     console.log(this)     
        //     // A.call(this)
        // }
        // // B.prototype = new A()
        // B()
        // console.log(B.prototype)

        // 相交链表，编写一个程序，找到两个单链表相交的起始节点。
        // 不会写理解不来
        // var getIntersectionNode = function(headA, headB) {
        //     console.log(headA,headB)
        //     let pA = headA, pB = headB
        //     while(pA || pB) {
        //         if(pA === pB) return pA
        //         pA = pA === null ? headB : pA.next
        //         pB = pB === null ? headA : pB.next
        //     }
        //     return null
        // };
        // console.log(getIntersectionNode({val: 4,next:{ val: 1, next:  { val: 8, next: {} } }}
        //                     ,{val: 5,next:{ val: 1, next:  { val: 8, next: {} } }}))



        // 返回倒数第 k 个节点
        // 乍一想到的解法
        // var kthToLast = function(head, k) {
        //     let count = 0,arr=[]
        //     while(head){
        //         arr.push(head.val)
        //         count++
        //         head = head.next
        //     }   
        //     return arr[arr.length - k]
        // };
        // 双指针法---性能很好
        // var kthToLast = function(head, k) {
        //     console.log(head,k)
        //     let left =head,right=head,i=0
        //     while(i<k){
        //         left = left.next
        //         i++
        //     }
        //     while(left){
        //         left = left.next
        //         right = right.next
        //     }
        //     console.log(right.val)
        // };
        // kthToLast({val: 4,next:{ val: 1, next:  { val: 8, next: null } }},2)



        // 给定一个二叉树，找出其最大深度。
        var maxDepth = function(root) {
            if(!root){return 0}
            else{
                console.log(Math.max(maxDepth(root.left),maxDepth(root.right)))
                return Math.max(maxDepth(root.left),maxDepth(root.right))+1
            }
            // 下面的解法没有考虑完整,没有左右左右去遍历
            // let a=0
            // while(root){
            //     a++
            //     root = root.left
            // }
            // while(root){
            //     b++
            //     root = root.right
            // }
            // console.log(a,b)
            // return Math.max(a,b)+1
        };
       console.log(maxDepth( { val: 3,
  left:  { val: 9, left: null, right: null },
  right:  {
    val: 20,
    left:  { val: 15, left: null, right: null },
    right:  { val: 7, left: null, right: null }
  }
}
)) 
    </script>
</body>
</html>