1.结果为7

因为a[i]= ... 会给函数开辟一个内存空间，a[i]会指向当前内存空间，当a【6】（）执行的时候会执行到第六次循环之后执行，此时当前函数的内存地址存储的i值为7

**错了，为10，因为i是全局变量，i已经变成10了**



2.报tmp未定义的错误，因为块级作用域内需要先声明后使用。



3.let min =arr.sort((a,b)=>a-b)[0]



4.var声明一个全局作用域，存在变量提升

​	let声明一个块级作用域，不存在变量提升，必须要先声明后使用，不允许重复声明，不覆盖全局变量

const 只读常量，声明必须赋值，不可更改



5. 20   因为this.a的this是fn（）函数的this指向一层层向上查找，直到找到最上层链为止，后面执行obj对象中有a变量  为20 所以输出



6.symbol类型的用途：创造一个独一无二的值

- **作为对象的属性，可以作为对象的私有属性，**

- **阻止对象上属性名的冲突，每个 Symbol 都独一无二的，可以保证不与其他属性名产生冲突，**

- **使用Symbol来替代常量**

  

7.浅拷贝：对于复杂数据类型，只拷贝了指针的指向，元素指向了同一块内存空间

   深拷贝：同时赋值内存空间，拷贝后的值指向新的内存空间



8.typeScript是javaScript的超集，支持js语法，解决了js类型系统的问题，代码更可靠，可以编译成js



9.typeScript：优点：解决了js类型系统的问题，代码更可靠，系统易于维护

​			缺点：多了很多概念（泛型，断言等），项目初期会增加很多学习成本



10.引用计数工作原理：维护一个全局计数器，对于里面的成员每一次引用的变更都修改数字，为0则回收

​	优点：回收迅速，最大限度解决一些程序暂停问题

​	缺点：无法回收循环引用的数据；时间开销大



11.标记整理算法：

​	1.循环遍历标记；2.循环遍历回收；3.回收的内存会放在一个内存空闲区；4.在释放内存空闲区之前会对碎片化的内存空闲区进行整理（解决标记回收的空间碎片化问题）；5：回收内存



12.新生代：采用复制算法+标记整理方式。把新生代的内存一分为二，使用空间from存储活动对象，内存空间to存储标记整理后的对象，然后交换空间完成释放。

新生代升级为老生代：1.第一轮gc之后未被回收的新生代；2.to空间使用率超过25%



13.增量算法 是与程序执行交替使用，以解决标记整理不会立即执行的问题

​	原理：遍历对象进行标记的时候增量标记