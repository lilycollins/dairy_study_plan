<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12月</title>
</head>
<body>
    <script>
        // 12.21
        /*
        // 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
        // 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
        // 注意：给定 n 是一个正整数。
        // posibility(x) = posibility（x-1）+ posibility（x-2）
        var climbStairs = function(n) {
            let posibility = new Array(n+1).fill(0)
            posibility[1] = 1;
            posibility[2] = 2;
            for(var i=3;i<=n;i++){
                posibility[i] = posibility[i-1] + posibility[i-2]
            }
            return posibility[n]
            
        };
        climbStairs(5)
        */
       /*
        // 使用最小花费爬楼梯   
        // 数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
        // 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
        // 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
        // dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
        var minCostClimbingStairs = function(cost) {
            let dp = new Array(cost.length+1)
            dp[0] = 0
            dp[1] = 0
            for(var i=2;i<dp.length;i++) {
                dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
            }
            console.log(dp[cost.length])           
        };
        minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])
        */
        /*
        // 记忆性递归，斐波那契数列
        function fibnacci(n){
            // 传统方式-递归-耗费性能-重复计算
            // if(n==0){return 0}
            // if(n==1){return 1}
            // else {
            //     return fibnacci(n-1)+fibnacci(n-2)
            // }
            // 优化-缓存-每个只需要算一次
            let result = [1,1]
            for(var i=2;i<n;i++){
                result[i] = result[i-1]+result[i-2]
            }        
            console.log(result[result.length-1])
            return result[result.length-1]           
        }
        console.log(fibnacci(16))
        */
        /*
        // 最小绝对差
        var minimumAbsDifference = function(arr) {
            // 先给数组排序，然后判断相邻项之间的绝对差，返回最小。    
            let result = []
            arr.sort((a,b)=>{
                return a-b
            })
            let min = arr[1] - arr[0]
            arr.forEach((ele, index) => {
                if(arr[index+1]-arr[index]<=min){
                    min = arr[index+1]-arr[index]
                    console.log(arr[index+1]-arr[index])
                } 
            });
            arr.forEach((ele, index) => {
                if(arr[index+1]-arr[index]==min){
                    result.push([arr[index], arr[index+1]])
                } 
            })
            console.log(result)  
        };
        minimumAbsDifference([3,8,-10,23,19,-4,-14,27])
        */
    //    12.23
    // // 字符串中的第一个唯一字符
    // var firstUniqChar = function(s) {
    //     for(var i=0;i<s.length;i++) {
    //         if(s.indexOf(s.charAt(i)) == s.lastIndexOf(s.charAt(i))) {
    //             return i
    //         }
    //     }
    //     return -1
    // };
    // firstUniqChar('loveleetcode')

    // 12.24
    // 合并两个有序数组
    // 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
    // 说明：
    // 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
    // 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
    // var merge = function(nums1, m, nums2, n) {
    //     let nums = []
    //     nums1.splice(m)
    //     nums2.splice(n)
    //     nums = nums1.concat(nums2).sort((a,b)=> {return a-b})
    //     console.log(nums)
    // };
    // merge([1,2,3,0,0,0], 3, [2,5,6], 3)
    // // 最富有客户的资产总量
    // // 输入：accounts = [[1,5],[7,3],[3,5]]
    // // 输出：10
    // // 解释：
    // // 第 1 位客户的资产总量 = 6
    // // 第 2 位客户的资产总量 = 10 
    // // 第 3 位客户的资产总量 = 8
    // // 第 2 位客户是最富有的，资产总量是 10
    // var maximumWealth = function(accounts) {
    //     console.log(999, accounts)
    //     let result = 0
    //     accounts[0].forEach(element => {
    //         result += element
    //     });
    //     console.log(9999, result)
    //     for(var i=1;i<accounts.length;i++){
    //         let sum = 0
    //         accounts[i].forEach(ele => {
    //             sum += ele
    //         })
    //         result = result>sum?result:sum
    //     }
    //     console.log('result', result)

    // };
    // maximumWealth([[1,5],[7,3],[3,5]])

    // // 12.28 移除无效括号
    // var minRemoveToMakeValid = function(s) {
    //     console.log(s)
    //     let arr = s.split('')
    //     // 设置一个栈，只维护一个栈元素。 可以存储（） 遍历字符串，遇到charAt('(')进栈，需要存储索引，未
    //     // 出栈时需要移除一个"("，好像移除的顺序不限制，所以也可不存储索引(顺序很重要，同时间尽量避免使用splice，
    //     // 会改变原数组，下标不准，用栈元素存储索引)，遇到charAt(')')的出栈
    //     let stack = []
    //     for(var i=0;i<arr.length;i++){
    //         if(arr[i]=='(') {
    //             stack.push(i)
    //         } else if(arr[i] == ')') {
    //             if(stack.length>0) {
    //                 stack.pop()
    //             } else {
    //                 delete (arr[i])
    //             }
    //         }
    //     }
    //     if(stack.length>0) {
    //         for(var i=0;i<stack.length;i++) {
    //             delete arr[stack[i]]
    //         }          
    //     }
    //     // arr = arr.filter(val=>val)
        
    // };
    // minRemoveToMakeValid("())()(((")

    // 12.29
    // 递归乘法
    // var multiply = function(A, B) {
    //     console.log(A, B)
    //     // // 尽量减少循环次数,用小值去循环
    //     // let sum = 0
    //     // let max = Math.max(A,B)
    //     // let min = Math.min(A,B)
    //     // for(var i=0;i<min;i++) {
    //     //     sum+=max
    //     // } 
    //     // console.log(sum)   
    //     if(B == 0) { return 0}  
    //     return A+multiply(A, B-1)
    // };
    // console.log(multiply(8, 7))
    // // 无法吃午餐的学生数量
    // var countStudents = function(students, sandwiches) {
    //     console.log(999, students, sandwiches)
    //     // 计数法，直接算出student和sandwishes中0和1的数量，相减。
    //     // 但是题目规定，只要顶层的三明治没人喜欢就结束.所以单纯的统计无法满足需求。
    //     // 只要顶层的三明治为0（1），学生数组都为1（0）的情况就可以返回学生数组长度了。
    //     while(students.includes(sandwiches[0])) {
    //         if(students[0]==sandwiches[0]) {
    //             students.splice(0, 1)
    //             sandwiches.splice(0,1)
    //         } else {
    //             students.push(students[0])
    //             students.splice(0, 1)
                
    //         }
    //     }
    //     console.log(11111, students)
        
    //     // console.log(s0,s1,w0,w1)
    //     // while(i<students.length) {
    //     //     if(students[i] == sandwiches[i]) {    
    //     //         delete students[i] 
    //     //         delete sandwiches[i]
    //     //     } else {
                 
    //     //         student.push(student[i])
    //     //     }
    //     //     i++
    //     // }
    // };
    // countStudents([1,1,1,0,0,1], [1,0,0,0,1,1])
    // 三步问题
    // 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。
    // 结果可能很大，你需要对结果模1000000007。
    // dp[i] = dp[i-1] + dp[i-2] + dp[i-3]// 动态转换方程是这样
    // var waysToStep = function(n) {
    //     if(n<3) return n;
    //     // // 状态转移方程
    //     // let dp = new Array(n)
    //     // console.log(n, dp)
    //     // dp[1] = 1
    //     // dp[2] = 2
    //     // dp[3] = 4
    //     // for(var i=4;i<=n;i++) {           
    //     //     dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
    //     // }
    //     // console.log(dp)
    //     // posibility(x) = posibility（x-1）+ posibility（x-2）+ posibility（x-3）
    //     // 优化之后
    //     let a=1,b=1,c=2,d=0
    //     for(var i=3;i<=n;i++) {
    //         d = a+b+c;
    //         a=b;
    //         b=c;
    //         c=d;
    //     }
    //     console.log(d)
    // };
    // waysToStep(10)
    // 各位数的和
    // var runningSum = function(nums) {
    //     let len = nums.length;
    //     let result = new Array(len)
    //     result[0] = nums[0]
    //     for(var i=1;i<len;i++) {
    //         result[i] = result[i-1] + nums[i]
    //     }
    //     return result
    // };
    // runningSum([3,1,2,10,1])
    // 剑指 Offer 58 - II. 左旋转字符串
    var reverseLeftWords = function(s, n) {
        console.log(s.slice(n)+s.slice(0,n))
    };
    reverseLeftWords("abcdefg", 2)
    </script>
</body>
</html>