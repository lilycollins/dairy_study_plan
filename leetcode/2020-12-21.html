<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>爬楼梯</title>
</head>
<body>
    <script>
        /*
        // 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
        // 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
        // 注意：给定 n 是一个正整数。
        // posibility(x) = posibility（x-1）+ posibility（x-2）
        var climbStairs = function(n) {
            let posibility = new Array(n+1).fill(0)
            posibility[1] = 1;
            posibility[2] = 2;
            for(var i=3;i<=n;i++){
                posibility[i] = posibility[i-1] + posibility[i-2]
            }
            return posibility[n]
            
        };
        climbStairs(5)
        */
       /*
        // 使用最小花费爬楼梯   
        // 数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
        // 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
        // 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
        // dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
        var minCostClimbingStairs = function(cost) {
            let dp = new Array(cost.length+1)
            dp[0] = 0
            dp[1] = 0
            for(var i=2;i<dp.length;i++) {
                dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
            }
            console.log(dp[cost.length])           
        };
        minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])
        */
        /*
        // 记忆性递归，斐波那契数列
        function fibnacci(n){
            // 传统方式-递归-耗费性能-重复计算
            // if(n==0){return 0}
            // if(n==1){return 1}
            // else {
            //     return fibnacci(n-1)+fibnacci(n-2)
            // }
            // 优化-缓存-每个只需要算一次
            let result = [1,1]
            for(var i=2;i<n;i++){
                result[i] = result[i-1]+result[i-2]
            }        
            console.log(result[result.length-1])
            return result[result.length-1]           
        }
        console.log(fibnacci(16))
        */

        // 最小绝对差
        var minimumAbsDifference = function(arr) {
            // 先给数组排序，然后判断相邻项之间的绝对差，返回最小。    
            let min = arr[1] - arr[0]
            arr.sort((a,b)=>{
                return a-b
            })
            let current = 0
            arr.forEach((ele, index) => {
                if(arr[index+1]-arr[index]<=min){
                    min = arr[index+1]-arr[index]
                    console.log(arr[index],arr[index+1])
                    current++
                } 
            });
            console.log(11111, min, current)
            
        };
        minimumAbsDifference([3,8,-10,23,19,-4,-14,27])

    </script>
</body>
</html>